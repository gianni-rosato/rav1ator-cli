#!/bin/bash

# Specify input & output files as first & second CLI args
INFILE=$1
OUTFILE=$2
EXTENSION=${1##*.}
EXTENSION2=${2##*.}

# Escape codes for colors used throughout the tool's formatted text
AV1RED="\033[38;5;161m"
GREY="\033[38;5;248m"
BOLD="\033[1m"
ULINE="\033[4m"
BLINK="\033[5m"
RESET="\033[0m"

# Help strings
INTRO_HELP1="Binaries will be found in a folder called \"rav1ator_cli_encoders\" in your Home directory. Please copy these to your /usr/local/bin folder, which allows you to use Linux programs from anywhere on your computer in the terminal. You can do that by entering the command below."
INTRO_HELP2="sudo cp ~/rav1ator_cli_encoders/* /usr/local/bin"
INTRO_HELP3="If you're using ZSH, specifically with Oh My ZSH, you may only need to uncomment the second line by removing the \"#\" in front of it in your .zshrc file. You can edit this file by running \"nano ~/.zshrc\""

# Binary links for the pre-built binaries. From GitHub
rav1e_link="https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/bin/rav1e.zst"
x265_link="https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/bin/x265.zst"
x264_link="https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/bin/x264.zst"
svt_link="https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/bin/SvtAv1EncApp.zst"
aom_link="https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/bin/aomenc.zst"
legal_link="https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/bin/legal.tar.zst"


# Every time there's a significant user-facing update, this will change & is checked against rav1ator-cli.md5 (which is pulled from the git repo). to generate rav1ator-cli.md5, just `rm rav1ator-cli.md5 && md5sum rav1ator-cli | awk '{print $1}' >> rav1ator-cli.md5`.
script_md5=$(md5sum /usr/local/bin/rav1ator-cli | awk '{print $1}')
version="0.3.0"
bin_latest_date="21 August 2024"

# Check where the script is located
bin_loc=$(which rav1ator-cli)

# Is this a batch encode
is_batch_encode=0

# Check for updates by checking the script's hash against the latest hash in the git repo. Requires an internet connection.
update_hash_check () {
	str=$(curl -s https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/rav1ator-cli.md5)
	echo "$str"
}

update_prompt() {
    str=$(gum confirm "Install update now?" --selected.background="161" --selected.foreground="15" --unselected.foreground="248" && echo "Yes" || echo "No")
    echo "$str"
}

# Binary installation prompt if the user passes -b
encoders_download () {
	str=$(gum confirm "Download relevant encoder binaries?" --selected.background="161" --selected.foreground="15" --unselected.foreground="248" && echo "Yes" || echo "No")
	echo "$str"
}

# Return "Yes" to install the encoders to /usr/local/bin if the user confirms
encoders_install () {
	str=$(gum confirm "Install binaries to /usr/local/bin?" --selected.background="161" --selected.foreground="15" --unselected.foreground="248" && echo "Yes" || echo "No")
	echo "$str"
}

# If the user passes a help flag
if [[ "$*" == "-h" || "$*" == "--help" ]]; then
	echo -e "${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET} ${GREY}v$version${RESET}"
	echo -e ""
    echo -e "${GREY}Usage${RESET}:"
	echo -e "	rav1ator-cli [${AV1RED}input${RESET}] [${AV1RED}output${RESET}] [${GREY}--offline${RESET}]"
	echo -e ""
	echo -e "${GREY}Dependencies (Arch)${RESET}: "
	echo -e "	openssl ffmpeg python mkvtoolnix-cli vapoursynth gum numactl l-smash vapoursynth-plugin-lsmashsource av1an ffms2"
	echo -e ""
	echo -e "${GREY}Options${RESET}: (Currently, only one option is useful at a time)"
	echo -e "	-h, --help		Print this help section"
	echo -e "	-v, --version		Print version information"
	echo -e "	-l, --last-used		Print last used encode settings from history"
	echo -e "	-f, --full-history	Print full history from \".rav1ator-cli-history\" file"
	echo -e "	-b, --binaries		Just install binaries, then exit"
	echo -e "	-x, --offline		Don't check for updates."
	echo -e "	-a, --batch		Batch encode. All video files in a directory specified after this flag are encoded."
	exit 1

# If the user passes a last used flag, print last used in history
elif [[ "$*" == "-l" || "$*" == "--last-used" ]]; then
	lastused1=$(tail -n 2 ~/.rav1ator-cli-history | head -n 1)
	lastused2=$(tail -n 2 ~/.rav1ator-cli-history | tail -n 1)
	echo -e "${GREY}$lastused1${RESET}"
	echo -e "$lastused2"
	exit 1

# If the user passes a full history flag, print the full history
elif [[ "$*" == "-f" || "$*" == "--full-history" ]]; then
	cat ~/.rav1ator-cli-history
	exit 1

# If the user passes a binary installation flag, prompt to install binaries
elif [[ "$*" == "-b" || "$*" == "--binaries" ]]; then
	# Check for updates when -b flag is passed
	updateCheck=$(update_hash_check)
	if [[ "$updateCheck" == "" ]]; then
	    # If we can't fetch the script's hash from GitHub, inform the user and abort
	    echo -e "${BOLD}${GREY}Error${RESET}${GREY}: Could not fetch script hash.${RESET}"
		echo -e "${GREY}An internet connection is required for binary installation.${RESET}"
    exit 1
	elif [[ "$script_md5" != "$updateCheck" ]]; then
	    echo -n -e "${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET}"
        echo -e "\nThere is a ${BOLD}New Update${RESET} available!"
        echo -e "${GREY}We've downloaded it for you. Would you like to install to /usr/local/bin?${RESET}"
        # Download latest script from GitHub if we need to update
    	curl -sOJ https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/rav1ator-cli
    	chmod +x rav1ator-cli
    	# echo -e "sudo cp rav1ator-cli /usr/local/bin" # Installation instruction
    	confirmation=$(update_prompt)
    	if [[ "$confirmation" == "Yes" ]]; then
            echo -e "${GREY}>${RESET} ${AV1RED}Yes${RESET}"
            sudo cp rav1ator-cli /usr/local/bin
            rm -f rav1ator-cli
            echo -e "If you accepted the sudo prompt, the latest version should now be installed!"
            exit 1
        else
            echo -e "${GREY}>${RESET} ${AV1RED}No${RESET}"
            echo -e "${GREY}The latest version of rAV1ator CLI has been downloaded to the current directory.${RESET}"
            echo -e "${GREY}You can install it manually by running:${RESET} sudo cp rav1ator-cli /usr/local/bin"
            exit 1
        fi
exit 1
	else
		echo -e "Binaries last updated by rav1ator-cli on ${BOLD}$bin_latest_date${RESET}"
	fi
	manualInstall=$(encoders_download)
	case $manualInstall in
		"Yes")
		    echo -e "${GREY}>${RESET} ${AV1RED}Yes${RESET}"
			# Clean up old binary directory & make a new one
			rm -rf ~/rav1ator_cli_encoders
			mkdir ~/rav1ator_cli_encoders

			# Download encoder binaries to the binary directory in the user's home dir
			cd ~/rav1ator_cli_encoders || return; gum spin --spinner.foreground="161" --spinner line --title "Downloading legal information..." -- curl -OJ "$legal_link"
			cd ~/rav1ator_cli_encoders || return; gum spin --spinner.foreground="161" --spinner line --title "Downloading encoder aom-av1-lavish..." -- curl -OJ "$aom_link"
			cd ~/rav1ator_cli_encoders || return; gum spin --spinner.foreground="161" --spinner line --title "Downloading encoder SVT-AV1..." -- curl -OJ "$svt_link"
			cd ~/rav1ator_cli_encoders || return; gum spin --spinner.foreground="161" --spinner line --title "Downloading encoder rav1e..." -- curl -OJ "$rav1e_link"
			cd ~/rav1ator_cli_encoders || return; gum spin --spinner.foreground="161" --spinner line --title "Downloading encoder x264..." -- curl -OJ "$x264_link"
			cd ~/rav1ator_cli_encoders || return; gum spin --spinner.foreground="161" --spinner line --title "Downloading encoder x265..." -- curl -OJ "$x265_link"
			gum spin --spinner.foreground="161" --spinner line --title "Decompressing binary archives..." -- zstd -d ~/rav1ator_cli_encoders/*.zst && rm ~/rav1ator_cli_encoders/*.zst

			# Check the SHA256 hash of each binary to make sure they are correct
			rav1e_sum=$(sha256sum ~/rav1ator_cli_encoders/rav1e | awk '{print $1}' | tr -dc "abcdefg1234567890")
			x265_sum=$(sha256sum ~/rav1ator_cli_encoders/x265 | awk '{print $1}' | tr -dc "abcdefg1234567890")
			x264_sum=$(sha256sum ~/rav1ator_cli_encoders/x264 | awk '{print $1}' | tr -dc "abcdefg1234567890")
			svt_sum=$(sha256sum ~/rav1ator_cli_encoders/SvtAv1EncApp | awk '{print $1}' | tr -dc "abcdefg1234567890")
			aom_sum=$(sha256sum ~/rav1ator_cli_encoders/aomenc | awk '{print $1}' | tr -dc "abcdefg1234567890")
			legal_sum=$(sha256sum ~/rav1ator_cli_encoders/legal.tar | awk '{print $1}' | tr -dc "abcdefg1234567890")

			# If the hash is wrong, exit the tool & inform the user
			if [ "$rav1e_sum" != "51da17ab528c13ea3b97f765e85965f97048308ccd8012e55a61e2ada38527d6" ]; then
				echo -e "${GREY}Bad binary integrity detected:${RESET} rav1e"
				echo -e "${GREY}Please contact gianni-rosato on GitHub.${RESET}"
				exit 1
			elif [ "$x265_sum" != "e857e5c8b803de4849e0d75535ef5441008d6360327b7ff67d0e9295195a11e0" ]; then
				echo -e "${GREY}Bad binary integrity detected:${RESET} x265"
				echo -e "${GREY}Please contact gianni-rosato on GitHub.${RESET}"
				exit 1
			elif [ "$x264_sum" != "47a872f6485b5b925627c038946646db7a5b105d71c5a34869009b3a38da38d1" ]; then
				echo -e "${GREY}Bad binary integrity detected:${RESET} x264"
				echo -e "${GREY}Please contact gianni-rosato on GitHub.${RESET}"
				exit 1
			elif [ "$svt_sum" != "52e7546cb000cdb93897d3aa7ed89381e7eac83bce8ca3684f43fb24db153064" ]; then
				echo -e "${GREY}Bad binary integrity detected:${RESET} SvtAv1EncApp"
				echo -e "${GREY}Please contact gianni-rosato on GitHub.${RESET}"
				exit 1
			elif [ "$aom_sum" != "a8955f68ef94f05d263aa1be781225d61b68784a6de35a324bd7437d7aa84160" ]; then
				echo -e "${GREY}Bad binary integrity detected:${RESET} aomenc"
				echo -e "${GREY}Please contact gianni-rosato on GitHub.${RESET}"
				exit 1
			elif [ "$legal_sum" != "2bcbb1e170dccf0236292d8fd132d3880e70c90756984b7d1024220d125bd42c" ]; then
				echo -e "${GREY}Bad file integrity detected:${RESET} legal.tar"
				echo -e "${GREY}Please contact gianni-rosato on GitHub.${RESET}"
				exit 1
			fi

			# Extract legal tar and remove archive
			tar -xf legal.tar
			rm -f ~/rav1ator_cli_encoders/*.tar

			# Make binaries executable
			chmod +x ~/rav1ator_cli_encoders/*

			# Ask to install to /usr/local/bin
			copyToUsrLocalBin=$(encoders_install)

			case $copyToUsrLocalBin in
				"Yes")
					echo -e "${GREY}Prompting for permission to copy encoder binaries:${RESET}"
					sudo cp ~/rav1ator_cli_encoders/* /usr/local/bin
					echo -e "${GREY}Given you did not abort and /usr/local/bin is in your PATH, binaries should be successfully installed.${RESET}"
					rm -rf ~/rav1ator_cli_encoders
					exit 1
					;;
				"No")
					gum style --foreground 15 --border-foreground 248 --border double --align center --width 74 --margin "0 1" --align="left" --padding "0 1" "$INTRO_HELP1"
					sleep 0.1
					gum style --foreground 15 --border-foreground 161 --border double --align center --width 74 --margin "0 1" --align="left" --padding "0 1" "$INTRO_HELP2"
					sleep 0.1
					gum style --italic --foreground 248 --border-foreground 248 --border double --align center --width 74 --margin "0 1" --padding "1 1" "$INTRO_HELP3"
					sleep 0.1
					echo -ne "${GREY}Binaries require an AVX2-capable CPU (Haswell or newer) and are highly optimized, so they will almost certainly be faster (and likely also newer) than the default options offered by your package manager. "
					sleep 0.3
					echo -e "\e]8;;https://wiki.x266.mov/blog/av1-encoding-for-dummies/#arch\e\\Link for More Info\e]8;;\e\\"
					exit 1
					;;
			esac
			;;
		"No")
		    echo -e "${GREY}>${RESET} ${AV1RED}No${RESET}"
			# Notify that installation was aborted
			echo -e "${GREY}Binary installation aborted.${RESET}"
			exit 1
			;;
	esac

# If offline, set the script's MD5 hash to "DEBUG" to bypass update check
elif [[ "$*" == "-v" || "$*" == "--version" ]]; then
	echo -e "${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET}	v$version"
	echo -e "${GREY}Script MD5 Hash:${RESET}	$script_md5" # REMEMBER: this is your /usr/local/bin rvcli, NOT the script you're working on
	echo -e "${GREY}Binaries updated:${RESET}	$bin_latest_date"
	echo -e "${GREY}Made with${RESET} ${AV1RED}${BLINK}<3${RESET} ${GREY}by:${RESET}	Gianni Rosato"
	exit 1
elif [[ "$3" == "-x" || "$3" == "--offline" ]]; then
	script_md5="DEBUG"
elif [[ "$1" == "-a" || "$1" == "--batch" ]]; then
	if [ -z "$2" ]; then
		echo -e "${GREY}No directory string provided.${RESET}"
		exit 1
	fi
	is_batch_encode=1
	batch_dir_dumb="$2"
	batch_dir=$(echo "$batch_dir_dumb" | tr -d '/')
fi

# If the user has different args or no args, print generic output
if [[ $# != 2 && $3 != "-x" && $3 != "--offline" ]]; then
    echo -e "	${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET}	      ${GREY}v$version${RESET}"
    echo -e "	${GREY}Usage:${RESET} rav1ator-cli [${AV1RED}input${RESET}] [${AV1RED}output${RESET}]"
	echo -e "	${GREY}rav1ator-cli${RESET} -h ${GREY}/${RESET} --help ${GREY}to get help${RESET}"
    exit 1
fi

# If no extension on the input file, notify user
if [ -z "$EXTENSION" ]; then
    echo -e "	${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET}"
    echo -e "	Please make sure you have a valid input file."
    exit 1

# If wrong extension on output file, notify user
elif [[ "$EXTENSION2" != "mkv" && is_batch_encode -eq 0 ]]; then
    echo -e "	${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET}"
    echo -e "	Please make sure your output filename has the ${BOLD}.mkv${RESET} file extension."
    exit 1
fi

# Encoder Selection
encoder_select () {
	# Single threaded
	str=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" x264 x265 aomenc SVT-AV1 rav1e)
	echo "$str"
}

# Inform the user & allow them to select a speed preset for their encoder of choice
cpu_used_select_text () {
	case $encoder in
		"x264")
			str="Speed trades time for encoding efficiency. \nOptions are ultrafast, superfast, veryfast, faster, fast, medium, slow, ${ULINE}slower${RESET}, ${ULINE}veryslow${RESET}, or placebo. \nRecommended options are underlined."
			;;
		"x265")
			str="Speed trades time for encoding efficiency. \nOptions are ultrafast, superfast, veryfast, faster, fast, medium, ${ULINE}slow${RESET}, ${ULINE}slower${RESET}, ${ULINE}veryslow${RESET}, or placebo. \nRecommended options are underlined."
			;;
		"aomenc")
			str="CPU Used trades time for encoding efficiency, with lower being slower. \nType a number from 0 to 6. We recommend ${ULINE}3${RESET} or ${ULINE}4${RESET}."
			;;
		"SVT-AV1")
			str="Preset trades time for encoding efficiency, with lower being slower. \nType a number from 0 to 13. We recommend ${ULINE}2${RESET}, ${ULINE}4${RESET}, & ${ULINE}6${RESET}."
			;;
		"rav1e")
			str="Speed trades time for encoding efficiency, with lower being slower. \nType a number from 0 to 10. We recommend ${ULINE}2${RESET} through ${ULINE}8${RESET}."
			;;
	esac
	echo "$str"
}

# Prompt for user input to select speed
cpu_used_select () {
	case $encoder in
		"x264")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 9 --placeholder "Speed")
			;;
		"x265")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 9 --placeholder "Speed")
			;;
		"aomenc")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "CPU Used (Speed, lower = slower)")
			;;
		"SVT-AV1")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "Preset (Speed, lower = slower)")
			;;
		"rav1e")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "Speed (Speed, lower = slower)")
			;;
	esac
	echo "$str"
}

# CRF selection text
crf_used_select_text () {
	case $encoder in
		"x264")
			str="CRF trades file size for quality.\nLower numbers produce larger, higher-quality files.\nType a number from 1 to 51. We'd recommend ${ULINE}17${RESET} to start."
			;;
		"x265")
			str="CRF trades file size for quality; lower numbers produce larger, higher-quality files. \nType a number from 0 to 51. We'd recommend ${ULINE}21${RESET} to start."
			;;
		"aomenc")
			str="CQ trades file size for quality; lower numbers produce larger, higher-quality files. \nType a number from 0 to 63. We'd recommend ${ULINE}24${RESET} to start."
			;;
		"SVT-AV1")
			str="CRF trades file size for quality; lower numbers produce larger, higher-quality files. \nType a number from 0 to 63. We'd recommend ${ULINE}29${RESET} to start."
			;;
		"rav1e")
			str="Quantizer trades file size for quality; lower numbers produce larger, higher-quality files. \nType a number from 0 to 255. We'd recommend ${ULINE}80${RESET} to start. \nGoing above Quantizer 100 for live-action content is generally not recommended."
			;;
	esac
	echo "$str"
}

# The actual user input to set CRF
crf_used_select () {
	case $encoder in
		"x264")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "CRF")
			;;
		"x265")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "CRF")
			;;
		"aomenc")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "CQ")
			;;
		"SVT-AV1")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "CRF")
			;;
		"rav1e")
			str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 6 --placeholder "Quantizer")
			;;
	esac
	echo "$str"
}

# Tell the user what the "Default" encoding parameters are for
param_text () {
	str="Would you like to input custom encoder parameters? \"Default\" parameters are tested to excel perceptually in SDR at 1080p for live action. \nIf you're encoding HDR video, \"Default\" will not work for you. \nCustom parameters ${BOLD}will overwrite your speed & quality selections, so you'll need to manually specify them here.${RESET}"
	echo "$str"
}

# Allow the user to select their parameters from a couple presets
param_select () {
	if [[ "$encoder" == "aomenc" || "$encoder" == "SVT-AV1" ]]; then
		yn=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" Default HDR10 Animation Custom)
	elif [[ "$encoder" == "rav1e" ]]; then
		yn=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" Default HDR10 Custom)
	else
		yn=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" Default Custom)
	fi
	case $yn in
		"Custom")
			str="$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 72 --placeholder "Custom Encoder Parameters")"
			;;
		"Default")
			case $encoder in
				"x264")
					str="--threads 2 --open-gop --no-mbtree --aq-mode 3 --preset "$speed" --crf "$crf""
					;;
				"x265")
					str="--output-depth 10 --profile main10 -p "$speed" --crf "$crf""
					;;
				"aomenc")
					str="--good --bit-depth=10 --end-usage=q --threads=2 --tune=ssim --ssim-rd-mult=125 --tune-content=psy --arnr-maxframes=15 --arnr-strength=2 --enable-cdef=0 --loopfilter-control=3 --quant-sharpness=3 --deltaq-mode=1 --aq-mode=0 --enable-keyframe-filtering=1 --luma-bias=25 --luma-bias-strength=15 --luma-bias-midpoint=66 --enable-qm=1 --quant-b-adapt=1 --lag-in-frames=48 --sb-size=dynamic --disable-kf --kf-max-dist=9999 --cpu-used=$speed --cq-level=$crf --denoise-noise-level=$grain --enable-dnl-denoising=0"
					;;
				"SVT-AV1")
					str="--tune 3 --sharpness 2 --keyint -1 --lp 2 --irefresh-type 2 --crf "$crf" --preset "$speed" --film-grain "$grain""
					;;
				"rav1e")
					str="--tiles 8 --threads 2 --no-scene-detection --keyint 0 -s "$speed" --quantizer "$crf" --photon-noise "$grain""
					;;
			esac
			;;
		"HDR10")
			case $encoder in
				"aomenc")
					str="--good --bit-depth=10 --end-usage=q --threads=2 --tune=ssim --ssim-rd-mult=125 --tune-content=psy --arnr-maxframes=15 --arnr-strength=2 --enable-cdef=0 --loopfilter-control=3 --quant-sharpness=3 --deltaq-mode=6 --aq-mode=0 --enable-keyframe-filtering=1 --luma-bias=36 --luma-bias-strength=16 --luma-bias-midpoint=60 --enable-qm=1 --quant-b-adapt=1 --lag-in-frames=48 --sb-size=dynamic --disable-kf --kf-max-dist=9999 --cpu-used=$speed --cq-level=$crf --denoise-noise-level=$grain --enable-dnl-denoising=0 --color-primaries=bt2020 --transfer-characteristics=smpte2084 --matrix-coefficients=bt2020ncl"
					;;
				"SVT-AV1")
					str="--tune 3 --sharpness 2 --keyint -1 --lp 2 --irefresh-type 2 --crf "$crf" --preset "$speed" --film-grain "$grain" --color-primaries 9 --transfer-characteristics 16 --matrix-coefficients 9"
					;;
				"rav1e")
					str="--tiles 8 --threads 2 --no-scene-detection --keyint 0 -s "$speed" --quantizer "$crf" --photon-noise "$grain" --primaries BT2020 --transfer SMPTE2084 --matrix BT2020NCL"
					;;
			esac
			;;
		"Animation")
			case $encoder in
				"aomenc")
					str="--good --bit-depth=10 --end-usage=q --threads=2 --tune=ssim --tune-content=psy --arnr-maxframes=15 --arnr-strength=2 --enable-cdef=0 --loopfilter-control=1 --quant-sharpness=0 --deltaq-mode=1 --enable-chroma-deltaq=1 --aq-mode=0 --enable-keyframe-filtering=1 --luma-bias=0 --enable-qm=1 --lag-in-frames=48 --sb-size=dynamic --disable-kf --kf-max-dist=9999 --dist-metric=qm-psnr --quant-b-adapt=1 --qm-min=0 --qm-max=8 --min-q=1 --cpu-used=$speed --cq-level=$crf --denoise-noise-level=$grain --enable-dnl-denoising=0"
					;;
				"SVT-AV1")
					str="--tune 2 --keyint -1 --lp 2 --irefresh-type 2 --crf "$crf" --preset "$speed" --film-grain "$grain""
					;;
			esac
			;;
	esac
	echo "$str"
}

# Prompt for film grain synthesis
grain_text () {
	str="Would you like to add synthetic film grain to your video? \nThis is recommended for AV1 video, at a value of 1 or 2 to start."
	echo "$str"
}

# Confirm if user wants grain synth or not
grain_confirmation () {
	yn="$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" Yes No)"
	echo "$yn"
}

# Get user input grain value
grain_select () {
	gamnt=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "Film Grain Amount ($grain_scale)")
	echo "$gamnt"
}

# Ask about FFmpeg parameters for cropping and scaling
ffmpeg_text () {
	str="Would you like to input custom FFmpeg parameters? \nIf not, the dropdown has presets for scaling & cropping your video. \nIf you'd like to generate your own preset using a target width & height,\nplease note that the crop values will be split in half. \nFor example, a height crop value of 280 pixels means 140 off the top and bottom."
	echo "$str"
}

# If the user selects "Generate", have them input target width, target height, width crop, height crop
ffmpeg_gen_wid () {
	str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "Target Video Width")
	echo "$str"
}

ffmpeg_gen_hei () {
	str=$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "Target Video Height")
	echo "$str"
}

# Dropdown for selecting an FFmpeg preset
ffmpeg_select () {
	yn=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" None "Generate Crop..." "Generate Scale..." 1080p 720p "1080p BluRay" 4k Custom)
	case $yn in
		"Custom")
			str="$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 72 --placeholder "Custom FFmpeg Options")"
			;;
		"1080p")
			str="-vf scale=1920:1080:flags=bicubic:param0=0:param1=1/2"
			;;
		"None")
			str="-y"
			;;
		"720p")
			str="-vf scale=1280:720:flags=bicubic:param0=0:param1=1/2"
			;;
		"1080p BluRay")
			str="-vf scale=1920:1080:flags=bicubic:param0=0:param1=1/2,crop=iw:ih-280"
			;;
		"4k")
			str="-vf scale=3840:2160:flags=bicubic:param0=0:param1=1/2"
			;;
		"Generate Crop...")
			crow=$(ffmpeg_gen_wid)
			croh=$(ffmpeg_gen_hei)

			# Format this string based on what the user puts as 0 (or not)
			if [[ $crow == 0 && $croh == 0 ]]; then
				str="-y"
			elif [[ $crow == 0 ]]; then
				str="-vf crop=iw:$croh"
			elif [[ $croh == 0 ]]; then
				str="-vf crop=$crow:ih"
			else
				str="-vf crop=$crow:$croh"
			fi
			;;
		"Generate Scale...")
			wid=$(ffmpeg_gen_wid)
			hei=$(ffmpeg_gen_hei)

			# Format this string based on what the user puts as 0 (or not)
			if [[ $wid == 0 && $hei == 0 ]]; then
				str="-y"
			elif [[ $wid == 0 ]]; then
				str="-vf scale=iw:$hei:flags=bicubic:param0=0:param1=1/2"
			elif [[ $hei == 0 ]]; then
				str="-vf scale=$wid:ih:flags=bicubic:param0=0:param1=1/2"
			else
				str="-vf scale=$wid:$hei:flags=bicubic:param0=0:param1=1/2"
			fi
			;;
	esac
	echo "$str"
}

# Ask about audio parameters for audio encoding/stripping/filtering
audio_text () {
	str="Would you like to input custom audio parameters? \nIf not, the dropdown has presets for encoding, filtering, & stripping your audio."
	echo "$str"
}

# Dropdown for selecting an FFmpeg preset
audio_opts () {
	yn=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" None Strip "128K Opus Stereo" "256K AAC Stereo" "320K Vorbis Stereo" "224k Opus (5.1)" "280k Opus (6.1)" "336k Opus (7.1)" Custom)
	# "-c:a libopus -b:a 128k"

	case $yn in
		"Custom")
			str="$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 72 --placeholder "Custom Audio Options")"
			;;
		"None")
			str="-c:a copy"
			;;
		"Strip")
			str="-an"
			;;
		"128K Opus Stereo")
			str="-c:a libopus -b:a 128k -ac 2"
			;;
		"256K AAC Stereo")
			str="-c:a aac -aac_coder 1 -b:a 256k -ac 2"
			;;
		"320K Vorbis Stereo")
			str="-c:a libvorbis -b:a 320k -ac 2"
			;;
		"224k Opus (5.1)")
			str="-c:a libopus -mapping_family 1 -af aformat=channel_layouts=5.1 -b:a 224k"
			;;
		"280k Opus (6.1)")
			str="-c:a libopus -mapping_family 1 -af aformat=channel_layouts=6.1 -b:a 280k"
			;;
		"336k Opus (7.1)")
			str="-c:a libopus -mapping_family 1 -af aformat=channel_layouts=7.1 -b:a 336k"
			;;
	esac
	echo "$str"
}

# Inform the user about workers
worker_text () {
	str="Specifying your number of workers tells Av1an how many instances it should spawn of the encoder you selected. \nWith enough RAM, you should be able to set this to half the number of threads your CPU has. \nTyping 0 allows Av1an to spawn workers automatically, but it is usually conservative. Be cognisant of the amount of RAM available to you."
	echo "$str"
}

# Allow user to select number of Av1an workers
worker_select () {
	str="$(gum input --cursor.foreground="161" --prompt.foreground="248" --width 4 --placeholder "Number of Workers")"
	echo "$str"
}

chunkmethod_text () {
    str="The chunk method defines how Av1an splits up your video into smaller chunks for encoding. \nLsmash is the fastest, but can be less reliable. Bestsource is slower but more reliable. \nIf you're unsure, Bestsource is recommended."
    echo "$str"
}

# Chunk Method Selection
chunkmethod_select () {
	# Single threaded
	str=$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" Lsmash Bestsource)
	echo "$str"
}

# Chunk Method Option Return
chunkmethod_opt () {
    local method
    local selected_method
    method=$(chunkmethod_select)

    case $method in
        "Lsmash")
            selected_method="lsmash"
            ;;
        "Bestsource")
            selected_method="bestsource"
            ;;
    esac

    echo "$selected_method"
}

# Final prompt, asking user whether or not the want to start the encode, abort, start the encode with the resume option, or print the resulting script derived from their input
encode_start_select () {
	str="Missing"

	# If running a batch encode, present the user with different options so the batch can be triggered
	if [ $is_batch_encode -eq 1 ]; then
		str="$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" "Start Batch" "Abort" "Print Batch")"
	else
		str="$(gum choose --limit=1 --cursor.foreground="161" --item.foreground="248" Start Abort Resume Print)"
	fi

	echo "$str"
}

# # # # # # # # # # # # # # # # # #
# THE START OF THE ACTUAL PROGRAM #
# # # # # # # # # # # # # # # # # #

done=0 # set done to 0

# While done is equal to 0, do everything in here
while [[ $done -eq 0 ]] ; do
	# Pretty header
	echo -n -e "${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}_${RESET}"

	# Check if gum is installed, because gum is very important to this program
	isGumInstalled=$(which gum 2>&1 | awk '{print $2}' 2>&1)

	# If gum isn't installed inform the user and abort
	if [ "$isGumInstalled" == "no" ]; then
		echo -e "${GREY}Please install${RESET} gum ${GREY}from your package manager to get started.${RESET}"
		exit 1
	fi

	# If rav1ator-cli isn't in /usr/local/bin, admonish the user
	if [ "$bin_loc" != "/usr/local/bin/rav1ator-cli" ]; then
		echo -e "${GREY}Please install${RESET} rav1ator-cli ${GREY}to your /usr/local/bin to started.${RESET}"
		echo -e "${GREY}run${RESET} sudo cp rav1ator-cli /usr/local/bin ${GREY}in your current directory.${RESET}"
		exit 1
	fi

	# Check for updates, unless the script's MD5 hash reads "DEBUG" (which indicates we're running in offline mode)
	updateCheck=$(update_hash_check)
	if [[ "$script_md5" == "DEBUG" ]]; then
		echo -e " ${GREY}Running in offline mode, skipping update checks.${RESET}\n"
	elif [[ "$updateCheck" == "" ]]; then
	    # If we can't fetch the script's hash from GitHub, inform the user and abort
	    echo -e "\n${BOLD}${GREY}Error${RESET}${GREY}: Could not fetch script hash.${RESET}"
		echo -e "${GREY}Please check your internet connection or run rAV1ator CLI in offline mode.${RESET}"
        exit 1
	elif [[ "$script_md5" != "$updateCheck" ]]; then
        echo -e "\nThere is a ${BOLD}New Update${RESET} available!"
        echo -e "${GREY}We've downloaded it for you. Would you like to install to /usr/local/bin?${RESET}"
        # Download latest script from GitHub if we need to update
    	curl -sOJ https://raw.githubusercontent.com/gianni-rosato/rav1ator-cli/main/rav1ator-cli
    	chmod +x rav1ator-cli
    	confirmation=$(update_prompt)
    	if [[ "$confirmation" == "Yes" ]]; then
            echo -e "${GREY}>${RESET} ${AV1RED}Yes${RESET}"
            sudo cp rav1ator-cli /usr/local/bin
            rm -f rav1ator-cli
            echo -e "If you accepted the sudo prompt, ${GREY}v$version${RESET} should be installed!"
            exit 1
        else
            echo -e "${GREY}>${RESET} ${AV1RED}No${RESET}"
            echo -e "${GREY}The latest version of rAV1ator CLI has been downloaded to the current directory.${RESET}"
            echo -e "${GREY}You can install it manually by running:${RESET} sudo cp rav1ator-cli /usr/local/bin"
            exit 1
        fi
	else
		echo -e "\n"
	fi

	# Prompt users to install encoder binaries with simple instructions
	echo -e "If you'd like to install encoder binaries, please run ${BOLD}rav1ator-cli -b${RESET}"
	echo -e "${GREY}Binaries last updated on ${BOLD}$bin_latest_date${RESET}\n"

	# What encoder does the user want to use? They can select
	echo "Which encoder would you like to select?"
	encoder=$(encoder_select)
	case $encoder in
		"x264")
			encoder_av1an="x264"
			;;
		"x265")
			encoder_av1an="x265"
			;;
		"aomenc")
			grain_scale="1-50"
			encoder_av1an="aom"
			;;
		"SVT-AV1")
			grain_scale="1-50"
			encoder_av1an="svt-av1"
			;;
		"rav1e")
			grain_scale="1-64"
			encoder_av1an="rav1e"
			;;
	esac
    	echo -e "${GREY}>${RESET} ${AV1RED}$encoder${RESET}\n"

		# Speed the user set gets assigned to "speed" variable
    	speed_string=$(cpu_used_select_text)
    	echo -e "$speed_string"
    	speed=$(cpu_used_select)
    	echo -e "${GREY}>${RESET} ${AV1RED}$speed${RESET}\n"

		# CRF input valuee is assigned to "crf" variable
    	crf_string=$(crf_used_select_text)
    	echo -e "$crf_string"
    	crf=$(crf_used_select)
    	echo -e "${GREY}>${RESET} ${AV1RED}$crf${RESET}\n"

		# Unless we're encoding AV1, don't ask about grain
		if [[ "$encoder" != "x264" && "$encoder" != "x265" ]]; then
			grain_string=$(grain_text)
			echo -e "$grain_string"
			grain_confirm=$(grain_confirmation)
			if [ "$grain_confirm" == "Yes" ]; then
				grain=$(grain_select)
				echo -e "${GREY}>${RESET} ${AV1RED}$grain${RESET}\n"
			else
				grain=0
				echo -e "${GREY}No synthetic grain will be added.${RESET}\n"
			fi
    	fi

		# Asking for encoding parameters
    	paramtext=$(param_text)
    	echo -e "$paramtext"
    	params="$(param_select)"
    	echo -e "${GREY}>${RESET} ${AV1RED}\"$params\"${RESET}\n"

		# Asking for FFmpeg parameters
    	ffmpegtext=$(ffmpeg_text)
    	echo -e "$ffmpegtext"
    	ffmpegopts="$(ffmpeg_select)"
    	echo -e "${GREY}>${RESET} ${AV1RED}\"$ffmpegopts\"${RESET}\n"

		# Set resolution for scene detection based on user input for FFmpeg string.
		if [[ "$ffmpegopts" == "-vf scale=1280:720:flags=bicubic:param0=0:param1=1/2 -an" ]]; then
			sc_downscale_res="720"
		else
			sc_downscale_res="1080"
		fi

		# Asking for audio parameters
    	audiotext=$(audio_text)
    	echo -e "$audiotext"
    	audioopts="$(audio_opts)"
    	echo -e "${GREY}>${RESET} ${AV1RED}\"$audioopts\"${RESET}\n"

		# Asking for Av1an workers
    	worker_string=$(worker_text)
    	echo -e "$worker_string"
    	workers=$(worker_select)
    	echo -e "${GREY}>${RESET} ${AV1RED}$workers${RESET}\n"

        # Asking for Av1an chunk method
        chunk_text=$(chunkmethod_text)
        echo -e "$chunk_text"
        chunk_string=$(chunkmethod_opt)
        echo -e "${GREY}>${RESET} ${AV1RED}$chunk_string${RESET}\n"

		# Finally, asking if the user is ready to encoder
    	echo -e "${BOLD}Ready to encode?${RESET}"
    	encode_start=$(encode_start_select)
		echo -e "${GREY}>${RESET} ${AV1RED}$encode_start${RESET}\n"

    	case $encode_start in
    		"Start")
				# Spin the spinner to pretend something is happening
				gum spin sleep 1.3 --spinner.foreground="161" --spinner line --show-output --title "Generating script..."

				# Spin the spinner to show that we're generating a hash for the input file which will be used to make a temp dir & name the output script
    			RAND=$(gum spin md5sum $INFILE --spinner.foreground="161" --spinner line --show-output --title "Hashing input file..." | head -c 6)

				# Echo the generated script and goodbye message to a .sh file
    			echo -e "ulimit -n 200000 && av1an -i \"$INFILE\" --verbose --sc-pix-format=yuv420p --temp \"rAV1ator-CLI_temp${RAND}\" --split-method av-scenechange -m $chunk_string -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"$OUTFILE\"" > "rAV1ator-CLI_job${RAND}.sh"
				echo -e "echo -e \"${BOLD}Encoding Finished!${RESET} Thanks for checking out ${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}!${RESET}\"" >> "rAV1ator-CLI_job${RAND}.sh"

				# Handle history output to `.rav1ator-cli-history` text file
				echo "-------" >> ~/.rav1ator-cli-history
				date >> ~/.rav1ator-cli-history
				echo -e "ulimit -n 200000 && av1an -i \"$INFILE\" --verbose --sc-pix-format=yuv420p --temp \"rAV1ator-CLI_temp${RAND}\" --split-method av-scenechange -m $chunk_string -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"$OUTFILE\"" >> ~/.rav1ator-cli-history

				# Mark script as executable
				chmod +x "rAV1ator-CLI_job${RAND}.sh"

				# Spin the spinner again for dramatic effect
    			gum spin --spinner.foreground="161" --spinner line --title "Executing rAV1ator-CLI_job${RAND}.sh..." -- sleep 0.3

				# Execute generated Av1an script to begin encoding
    			./"rAV1ator-CLI_job${RAND}.sh"

    			rm "rAV1ator-CLI_job${RAND}.sh"
				;;
			"Start Batch")
				# Spin the spinner to pretend something is happening
				gum spin sleep 1.5 --spinner.foreground="161" --spinner line --show-output --title "Generating batch encode script..."

				# Generate random hex for RAND var for batch because it doesn't need to be consistent for the directory name
				RAND=$(openssl rand --hex 4)

				# Output directory within the batch encode directory so it doesn't endlessly encode (Av1an will error out when it sees the directory doesn't exist)
				mkdir "$batch_dir/rAV1ator-CLI_job${RAND}"

				# Echo the generated batch encoding script & goodbye message to a .sh file
				echo -e "ulimit -n 200000" > "rAV1ator-CLI_job${RAND}.sh"
    			echo -e "find "$batch_dir" \( -name "\*.mkv" -o -name "\*.y4m" -o -name "\*.mp4" -o -name "\*.flv" -o -name "\*.webm" -o -name "\*.ivf" -o -name "\*.flv" -o -name "\*.yuv" \) -execdir av1an -i {} --verbose --sc-pix-format=yuv420p --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o rAV1ator-CLI_job${RAND}/{}-encoded.mkv \;" >> "rAV1ator-CLI_job${RAND}.sh"
				echo -e "echo -e \"${BOLD}Encoding Finished!${RESET} Thanks for checking out ${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}!${RESET}\"" >> "rAV1ator-CLI_job${RAND}.sh"

				# Handle history output to `.rav1ator-cli-history` text file
				echo "-------" >> ~/.rav1ator-cli-history
				date >> ~/.rav1ator-cli-history
				echo -e "av1an -i \"genericInput.mkv\" --verbose --sc-pix-format=yuv420p --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o genericOutput.mkv" >> ~/.rav1ator-cli-history

				# Mark script as executable
				chmod +x "rAV1ator-CLI_job${RAND}.sh"

				# Spin the spinner again for dramatic effect
    			gum spin --spinner.foreground="161" --spinner line --title "Executing rAV1ator-CLI_job${RAND}.sh..." -- sleep 0.3

				# Execute generated Av1an script to begin encoding
    			./"rAV1ator-CLI_job${RAND}.sh"

				# Once it is done or the user cancels, remove the generated script
    			rm "rAV1ator-CLI_job${RAND}.sh"
				;;
    		"Abort")
				# Inform the user they've aborted. Sad :(
    			echo -e "${GREY}Encoding aborted.${RESET}"
    			;;
    		"Resume")
				# Spin the spinner to pretend something is happening
				gum spin sleep 1.3 --spinner.foreground="161" --spinner line --show-output --title "Generating script..."

				# Spin the spinner to show that we're generating a hash for the input file which will be used to make a temp dir & name the output script
    			RAND=$(gum spin md5sum $INFILE --spinner.foreground="161" --spinner line --show-output --title "Hashing input file..." | head -c 6)

				# The only difference between "Yes" and "Resume" is that this one has a resume flag. I don't think this should be the default
    			echo -e "ulimit -n 200000 && av1an -i \"$INFILE\" --verbose --sc-pix-format=yuv420p --resume --temp \"rAV1ator-CLI_temp${RAND}\" --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"$OUTFILE\"" > "rAV1ator-CLI_job${RAND}.sh"
    			echo -e "echo -e \"${BOLD}Encoding Finished!${RESET} Thanks for checking out ${BOLD}rAV1ator${RESET}${GREY}:${RESET} ${AV1RED}${BOLD}CLI${RESET} ${BOLD}Edition${RESET}${GREY}${BLINK}${BOLD}!${RESET}\"" >> "rAV1ator-CLI_job${RAND}.sh"

				# Handle history output to `.rav1ator-cli-history` text file
				echo "-------" >> ~/.rav1ator-cli-history
				date >> ~/.rav1ator-cli-history
				echo -e "ulimit -n 200000 && av1an -i \"$INFILE\" --verbose --sc-pix-format=yuv420p --resume --temp \"rAV1ator-CLI_temp${RAND}\" --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"$OUTFILE\"" >> ~/.rav1ator-cli-history

				# Mark script as executable
				chmod +x "rAV1ator-CLI_job${RAND}.sh"

				# Spin the spinner again for dramatic effect
				gum spin --spinner.foreground="161" --spinner line --title "Executing rAV1ator-CLI_job${RAND}.sh..." -- sleep 0.3

				# Execute generated Av1an script with resume to begin/resume encoding
				./"rAV1ator-CLI_job${RAND}.sh"

				# Once it is done or the user cancels, remove the generated script
    			rm "rAV1ator-CLI_job${RAND}.sh"
				;;
			"Print")
				# Spin the spinner to pretend something is happening
				gum spin sleep 1.2 --spinner.foreground="161" --spinner line --show-output --title "Generating script..."

				# Print the Av1an command to the terminal
				echo -e "${GREY}Generated script${RESET}${AV1RED}:${RESET} av1an -i \"$INFILE\" --verbose --sc-pix-format=yuv420p --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"$OUTFILE\""

				# Handle history output to `.rav1ator-cli-history` text file
				echo "-------" >> ~/.rav1ator-cli-history
				date >> ~/.rav1ator-cli-history
				echo -e "av1an -i \"$INFILE\" --verbose --sc-pix-format=yuv420p --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"$OUTFILE\"" >> ~/.rav1ator-cli-history

				# Inform the user that the printed output is also in their history
				echo -e "${GREY}Printed script added to history.${RESET}"
				;;
			"Print Batch")
				# Spin the spinner to pretend something is happening
				gum spin sleep 1.5 --spinner.foreground="161" --spinner line --show-output --title "Generating generic script..."

				# Print the non-batch Av1an command to the terminal
    			echo -e "${GREY}Generated script${RESET}${AV1RED}:${RESET} av1an -i \"genericInput.mkv\" --verbose --sc-pix-format=yuv420p --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"genericOutput.mkv\""

				# Handle history output to `.rav1ator-cli-history` text file
				echo "-------" >> ~/.rav1ator-cli-history
				date >> ~/.rav1ator-cli-history
				echo -e "av1an -i \"genericInput.mkv\" --verbose --sc-pix-format=yuv420p --split-method av-scenechange -m bestsource -c mkvmerge --sc-downscale-height $sc_downscale_res -e "$encoder_av1an" --force -v \"$params\" --pix-format yuv420p10le -f \"$ffmpegopts\" -a \"$audioopts\" --set-thread-affinity 2 -w $workers -o \"genericOutput.mkv\"" >> ~/.rav1ator-cli-history

				# Inform the user that the printed output is also in their history
				echo -e "${GREY}Printed script added to history. Please note this is a generic single-file script based on your specified settings that will not work on a folder/directory of videos.${RESET}"
				;;
    	esac

# Set done equal to 1 so that we can exit the while loop
done=1

done
